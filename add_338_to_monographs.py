# -*- coding: utf-8 -*-
"""Add338toMonographs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tvM9xr8S_L-ZxF1cVLQRrjjJHWz3OUVg
"""

import pandas as pd
from google.colab import drive
drive.mount('/content/drive/')

!ls

pip install pymarc

import requests
import yaml
import csv
from oauthlib.oauth2 import BackendApplicationClient
from requests.auth import HTTPBasicAuth
from requests_oauthlib import OAuth2Session
from pymarc import MARCReader, MARCWriter, Field, Subfield

with open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Add 338 to Monographs/metadata2_config.yml", 'r') as stream:
    config = yaml.safe_load(stream)

serviceURL = config.get('metadata_service_url')

scope = ['WorldCatMetadataAPI:manage_bibs'] # Note that scope is set to work with bibs

auth = HTTPBasicAuth(config.get('key'), config.get('secret'))
client = BackendApplicationClient(client_id=config.get('key'), scope=scope)
wskey = OAuth2Session(client=client)

token = wskey.fetch_token(token_url=config.get('token_url'), auth=auth)
print(token)

def generate_338_field(marc_file):
    with open(marc_file, "rb") as fh: # Note that we had "response.mrc" instead of marc_file in other scripts
        reader = MARCReader(fh)
        for record in reader:
            new_338_field = Field(
                tag='338',
                indicators = [' ',' '],
                subfields = [
                    Subfield(code='a', value="volume"),
                    Subfield(code='b', value="nc"),
                    Subfield(code='2', value="rdacarrier")
                ]
            )
            record.add_ordered_field(new_338_field)

            writer = MARCWriter(open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Add 338 to Monographs/edited.mrc", "wb"))
            writer.write(record)
            writer.close()

def write_chunk(control_num, response):
    with open('/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Add 338 to Monographs/track_response_codes.csv', 'a') as response_codes:
        writer = csv.writer(response_codes)
        writer.writerow([control_num, response])

with open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/DataforAPIOnboarding/BooksNo338.csv") as csv_file:
    reader = csv.DictReader(csv_file)
    for line in reader:
        ocn = line['ocn'] # "ocn" is the header of the column in the csv file

        print("working on:", ocn)

        # Send GET request
        try:
            r = wskey.get(serviceURL + f"/manage/bibs/{ocn}", headers={'Accept': 'application/marc'})
            r.raise_for_status()

            # Write MARC from API to mrc file on local machine
            with open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Add 338 to Monographs/response.mrc", "wb") as start_file:
                start_file.write(r.content)
            # Read mrc file saved on local machine
            generate_338_field("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Add 338 to Monographs/response.mrc")

            # Read mrc file on local machine to send put request with edited record content to API
            with open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Add 338 to Monographs/edited.mrc", "rb") as updated_record:
                reader2 = MARCReader(updated_record)
                for record in reader2:
                    response = wskey.put(serviceURL + f"/manage/bibs/{ocn}", data=record.as_marc(), headers={'Content-Type': 'application/marc'})
                    #Put operations typically need a 'Content-Type' header to announce the file type rather than an 'Accept' header.
                reader2.close()
            print(response) #This will return the status code of the operation, 200=success 403=forbidden, etc. you can also print(response.text) to obtain more detailed info. This can be very useful for debugging
            write_chunk(ocn, response)
        except requests.exceptions.HTTPError as err:
            print(err)
        except BaseException as err:
            print(err)