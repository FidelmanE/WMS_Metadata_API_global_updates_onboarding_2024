# -*- coding: utf-8 -*-
"""Receipt Status.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NIY5Qjbu3OuAnTDvzMTeCbU9tbUmrTI5
"""

import pandas as pd
from google.colab import drive
drive.mount('/content/drive/')

!ls

pip install pymarc

#pip install bookops-worldcat

import requests
import yaml
import os
import csv
from oauthlib.oauth2 import BackendApplicationClient
from requests.auth import HTTPBasicAuth
from requests_oauthlib import OAuth2Session
from pymarc import MARCReader, MARCWriter, Field

def edit_008(marc_file):
    with open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Receipt Status/response.mrc", "rb") as fh:
        # Read the MARC file (saved to local machine)
        reader = MARCReader(fh)
        for record in reader:
            # Pull all 008 fields (should only be one)
            old_fields = record.get_fields('008')
            for old_field in old_fields:
                # Convert old 008 content to string, create list to edit, create new 008 content string
                content_008 = old_field.format_field()
                list_008 = list(content_008)
                # List created because strings can't be edited
                list_008[6] = '5' # Change this value according to the receipt status to be assigned
                new008_content = ''.join(list_008) # New string created from edited list
                # Remove old 008 field
                record.remove_field(old_field)
            # Create new 008 field with edited content
            new_008_field = Field(
                tag='008',
                data=f"{new008_content}"
            )
            # Add new 008 field to record
            record.add_ordered_field(new_008_field)

            # Write edited MARC to new mrc file on local machine
            writer = MARCWriter(open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Receipt Status/edited.mrc", "wb"))
            writer.write(record)
            writer.close()

#Capture response codes
def write_chunk(control_num, response):
    with open('/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Receipt Status/response_codes.csv', 'a') as response_codes:
        writer = csv.writer(response_codes)
        writer.writerow([control_num, response])

with open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Receipt Status/metadata2_config.yml", 'r') as stream:
    config = yaml.safe_load(stream)

serviceURL = config.get('metadata_service_url')

"""Change scope below to work with Bibs"""

scope = ['WorldCatMetadataAPI:manage_institution_lhrs']

auth = HTTPBasicAuth(config.get('key'), config.get('secret'))
client = BackendApplicationClient(client_id=config.get('key'), scope=scope)
wskey = OAuth2Session(client=client)

token = wskey.fetch_token(token_url=config.get('token_url'), auth=auth)
print(token)

with open(f"/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/DataforAPIOnboarding/API_LHR_test.csv") as csv_file:
  reader = csv.DictReader(csv_file)
  for line in reader:
    control_num = line["control_num"]
    print("working on:", control_num)
    try:
      r = wskey.get(serviceURL + f"/manage/lhrs/{control_num}", headers={'Accept': 'application/marc'})
      r.raise_for_status()
      with open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Receipt Status/response.mrc", "wb") as start_file:
        start_file.write(r.content)
      edit_008("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Receipt Status/response.mrc")
      with open("/content/drive/My Drive/Data Services/API Batch Edits On-Boarding/Receipt Status/edited.mrc", "rb") as updated_record:
        reader2 = MARCReader(updated_record)
        for record in reader2:
          response = wskey.put(serviceURL + f"/manage/lhrs/{control_num}", data=record.as_marc(), headers={'Content-Type': 'application/marc'})
        reader2.close()
      print(response)
      write_chunk(control_num, response)
    except requests.exceptions.HTTPError as err:
      print(err)
    except BaseException as err:
      print(err)